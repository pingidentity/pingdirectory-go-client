/*
PingData Config - OpenAPI 3.0

This is the PingData Configuration API

API version: 0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// EnumtopologyAdminUserIsProxyableProp This can be used to indicate whether the User can be used as an alternate authorization identity (using the proxied authorization v1 or v2 control, the intermediate client control, or a SASL mechanism that allows specifying an alternate authorization identity).
type EnumtopologyAdminUserIsProxyableProp string

// List of Enumtopology-admin-user-isProxyableProp
const (
	ENUMTOPOLOGYADMINUSERISPROXYABLEPROP_ALLOWED    EnumtopologyAdminUserIsProxyableProp = "allowed"
	ENUMTOPOLOGYADMINUSERISPROXYABLEPROP_PROHIBITED EnumtopologyAdminUserIsProxyableProp = "prohibited"
	ENUMTOPOLOGYADMINUSERISPROXYABLEPROP_REQUIRED   EnumtopologyAdminUserIsProxyableProp = "required"
)

// All allowed values of EnumtopologyAdminUserIsProxyableProp enum
var AllowedEnumtopologyAdminUserIsProxyablePropEnumValues = []EnumtopologyAdminUserIsProxyableProp{
	"allowed",
	"prohibited",
	"required",
}

func (v *EnumtopologyAdminUserIsProxyableProp) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := EnumtopologyAdminUserIsProxyableProp(value)
	for _, existing := range AllowedEnumtopologyAdminUserIsProxyablePropEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid EnumtopologyAdminUserIsProxyableProp", value)
}

// NewEnumtopologyAdminUserIsProxyablePropFromValue returns a pointer to a valid EnumtopologyAdminUserIsProxyableProp
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewEnumtopologyAdminUserIsProxyablePropFromValue(v string) (*EnumtopologyAdminUserIsProxyableProp, error) {
	ev := EnumtopologyAdminUserIsProxyableProp(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for EnumtopologyAdminUserIsProxyableProp: valid values are %v", v, AllowedEnumtopologyAdminUserIsProxyablePropEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v EnumtopologyAdminUserIsProxyableProp) IsValid() bool {
	for _, existing := range AllowedEnumtopologyAdminUserIsProxyablePropEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to Enumtopology-admin-user-isProxyableProp value
func (v EnumtopologyAdminUserIsProxyableProp) Ptr() *EnumtopologyAdminUserIsProxyableProp {
	return &v
}

type NullableEnumtopologyAdminUserIsProxyableProp struct {
	value *EnumtopologyAdminUserIsProxyableProp
	isSet bool
}

func (v NullableEnumtopologyAdminUserIsProxyableProp) Get() *EnumtopologyAdminUserIsProxyableProp {
	return v.value
}

func (v *NullableEnumtopologyAdminUserIsProxyableProp) Set(val *EnumtopologyAdminUserIsProxyableProp) {
	v.value = val
	v.isSet = true
}

func (v NullableEnumtopologyAdminUserIsProxyableProp) IsSet() bool {
	return v.isSet
}

func (v *NullableEnumtopologyAdminUserIsProxyableProp) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableEnumtopologyAdminUserIsProxyableProp(val *EnumtopologyAdminUserIsProxyableProp) *NullableEnumtopologyAdminUserIsProxyableProp {
	return &NullableEnumtopologyAdminUserIsProxyableProp{value: val, isSet: true}
}

func (v NullableEnumtopologyAdminUserIsProxyableProp) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableEnumtopologyAdminUserIsProxyableProp) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
