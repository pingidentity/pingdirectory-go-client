/*
PingData Config - OpenAPI 3.0

This is the PingData Configuration API

API version: 0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package configurationapi

import (
	"encoding/json"
	"fmt"
)

// EnumrootDnUserIsProxyableProp This can be used to indicate whether the User can be used as an alternate authorization identity (using the proxied authorization v1 or v2 control, the intermediate client control, or a SASL mechanism that allows specifying an alternate authorization identity).
type EnumrootDnUserIsProxyableProp string

// List of Enumroot-dn-user-isProxyableProp
const (
	ENUMROOTDNUSERISPROXYABLEPROP_ALLOWED    EnumrootDnUserIsProxyableProp = "allowed"
	ENUMROOTDNUSERISPROXYABLEPROP_PROHIBITED EnumrootDnUserIsProxyableProp = "prohibited"
	ENUMROOTDNUSERISPROXYABLEPROP_REQUIRED   EnumrootDnUserIsProxyableProp = "required"
)

// All allowed values of EnumrootDnUserIsProxyableProp enum
var AllowedEnumrootDnUserIsProxyablePropEnumValues = []EnumrootDnUserIsProxyableProp{
	"allowed",
	"prohibited",
	"required",
}

func (v *EnumrootDnUserIsProxyableProp) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := EnumrootDnUserIsProxyableProp(value)
	for _, existing := range AllowedEnumrootDnUserIsProxyablePropEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid EnumrootDnUserIsProxyableProp", value)
}

// NewEnumrootDnUserIsProxyablePropFromValue returns a pointer to a valid EnumrootDnUserIsProxyableProp
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewEnumrootDnUserIsProxyablePropFromValue(v string) (*EnumrootDnUserIsProxyableProp, error) {
	ev := EnumrootDnUserIsProxyableProp(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for EnumrootDnUserIsProxyableProp: valid values are %v", v, AllowedEnumrootDnUserIsProxyablePropEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v EnumrootDnUserIsProxyableProp) IsValid() bool {
	for _, existing := range AllowedEnumrootDnUserIsProxyablePropEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to Enumroot-dn-user-isProxyableProp value
func (v EnumrootDnUserIsProxyableProp) Ptr() *EnumrootDnUserIsProxyableProp {
	return &v
}

type NullableEnumrootDnUserIsProxyableProp struct {
	value *EnumrootDnUserIsProxyableProp
	isSet bool
}

func (v NullableEnumrootDnUserIsProxyableProp) Get() *EnumrootDnUserIsProxyableProp {
	return v.value
}

func (v *NullableEnumrootDnUserIsProxyableProp) Set(val *EnumrootDnUserIsProxyableProp) {
	v.value = val
	v.isSet = true
}

func (v NullableEnumrootDnUserIsProxyableProp) IsSet() bool {
	return v.isSet
}

func (v *NullableEnumrootDnUserIsProxyableProp) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableEnumrootDnUserIsProxyableProp(val *EnumrootDnUserIsProxyableProp) *NullableEnumrootDnUserIsProxyableProp {
	return &NullableEnumrootDnUserIsProxyableProp{value: val, isSet: true}
}

func (v NullableEnumrootDnUserIsProxyableProp) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableEnumrootDnUserIsProxyableProp) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
